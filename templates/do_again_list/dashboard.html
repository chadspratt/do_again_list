<!DOCTYPE html>
<html>
<head>
    <title>Do Again List</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f0f2f5; color: #333; padding: 20px; }

        /* Header */
        .header { background: #fff; border-radius: 8px; padding: 20px 24px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.1); display: flex; justify-content: space-between; align-items: center; }
        .header h1 { font-size: 1.8rem; }

        /* Messages */
        .messages { margin-bottom: 16px; }
        .messages .success { background: #d4edda; color: #155724; padding: 10px 14px; border-radius: 6px; margin-bottom: 6px; }
        .messages .error { background: #f8d7da; color: #721c24; padding: 10px 14px; border-radius: 6px; margin-bottom: 6px; }

        /* Buttons */
        .btn { display: inline-block; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: .85rem; text-decoration: none; color: #fff; }
        .btn-primary { background: #0d6efd; }
        .btn-primary:hover { background: #0b5ed7; }
        .btn-success { background: #198754; }
        .btn-success:hover { background: #157347; }
        .btn-danger { background: #dc3545; }
        .btn-danger:hover { background: #bb2d3b; }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #5a6268; }
        .btn-sm { padding: 6px 12px; font-size: .8rem; }

        /* Modal / forms */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,.4); z-index: 100; justify-content: center; align-items: flex-start; padding-top: 80px; }
        .modal-overlay.active { display: flex; }
        .modal { background: #fff; border-radius: 10px; padding: 24px; width: 500px; max-width: 95vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 30px rgba(0,0,0,.2); }
        .modal h2 { margin-bottom: 16px; font-size: 1.2rem; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-weight: 600; margin-bottom: 4px; font-size: .85rem; }
        .form-group input, .form-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: .9rem; }
        .form-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }

        /* Events Grid */
        .events-container { max-width: 1500px; margin: 0 auto; }
        .events-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(236px, 1fr)); gap: 16px; }
        .event-card { background: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.1); border-left: 4px solid #0d6efd; position: relative; }
        .event-card .event-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; color: #1a1a1a; padding-right: 30px; }
        .event-card .event-date { font-size: .85rem; color: #666; margin-bottom: 12px; }
        .event-card .event-timer { font-size: 1.5rem; font-weight: 700; color: #0d6efd; margin-bottom: 16px; min-height: 36px; }
        .event-card .event-actions { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .event-card .event-actions input[type="text"] { flex: 1; min-width: 100px; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: .8rem; }
        .event-card .delete-icon { position: absolute; top: 12px; right: 12px; cursor: pointer; font-size: 1.2rem; opacity: 0.5; transition: opacity 0.2s; }
        .event-card .delete-icon:hover { opacity: 1; }
        .event-card .duration-icon { position: absolute; top: 12px; right: 38px; cursor: pointer; font-size: 1.2rem; opacity: 0.5; transition: opacity 0.2s; }
        .event-card .duration-icon:hover { opacity: 1; }
        .event-card .min-time-icon { position: absolute; top: 12px; right: 64px; cursor: pointer; font-size: 1.2rem; opacity: 0.5; transition: opacity 0.2s; }
        .event-card .min-time-icon:hover { opacity: 1; }
        .events-empty { text-align: center; color: #999; padding: 60px 20px; font-size: 1.1rem; background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.1); }
    </style>
</head>
<body>

{% if messages %}
<div class="messages">
    {% for message in messages %}
    <div class="{{ message.tags }}">{{ message }}</div>
    {% endfor %}
</div>
{% endif %}

<!-- Header -->
<div class="header">
    <h1>‚è±Ô∏è Do Again List</h1>
    <button class="btn btn-primary" onclick="document.getElementById('newEventModal').classList.add('active')">+ Add Event</button>
</div>

<!-- Events Grid -->
<div class="events-container">
    <div class="events-grid" id="eventsList">
        {% if events %}
        {% for event in events %}
        <div class="event-card" data-event-id="{{ event.id }}" data-event-start="{{ event.start_time.isoformat }}" data-event-end="{% if event.end_time %}{{ event.end_time.isoformat }}{% endif %}" data-default-duration="{{ event.default_duration }}" data-min-time="{{ event.min_time_between_events }}">
            <span class="delete-icon" onclick="deleteEvent({{ event.id }})" title="Delete event">üóëÔ∏è</span>
            <span class="duration-icon" onclick="openDurationModal({{ event.id }}, {{ event.default_duration }})" title="Set default duration">üïê</span>
            <span class="min-time-icon" onclick="openMinTimeModal({{ event.id }}, '{{ event.min_time_between_events }}')" title="Set min time between events">üö´</span>
            <div class="event-title">{{ event.title }}</div>
            <div class="event-date" data-date-display="{{ event.id }}"></div>
            <div class="event-timer" data-timer="{{ event.id }}"></div>
            <div class="event-actions" id="startActions{{ event.id }}">
                <input type="text" placeholder="start e.g. 1h30m" id="startInput{{ event.id }}"{% if not event.end_time %} style="display:none"{% endif %}>
                <button class="btn btn-success btn-sm" onclick="startEvent({{ event.id }})"{% if not event.end_time %} style="display:none"{% endif %}>Start</button>
            </div>
            <div class="event-actions" id="endActions{{ event.id }}" style="margin-top: 6px;">
                <input type="text" placeholder="end e.g. 1h30m" id="endInput{{ event.id }}">
                <button class="btn btn-primary btn-sm" onclick="endEvent({{ event.id }})">End</button>
            </div>
        </div>
        {% endfor %}
        {% else %}
        <div class="events-empty">No events yet. Click "Add Event" to create your first one.</div>
        {% endif %}
    </div>
</div>

<!-- Duration Modal -->
<div class="modal-overlay" id="durationModal" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="modal">
        <h2>Default Duration</h2>
        <input type="hidden" id="durationEventId">
        <div class="form-group">
            <label>Duration (minutes)</label>
            <input type="number" id="durationInput" min="0" placeholder="e.g. 60">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">Used to auto-fill start time when clicking End and the start input is blank. Set to 0 to disable.</small>
        </div>
        <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="document.getElementById('durationModal').classList.remove('active')">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="saveDuration()">Save</button>
        </div>
    </div>
</div>

<!-- Min Time Between Events Modal -->
<div class="modal-overlay" id="minTimeModal" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="modal">
        <h2>Min Time Between Events</h2>
        <input type="hidden" id="minTimeEventId">
        <div class="form-group">
            <label>Minimum time (e.g. 1d5h, 2h, 30m)</label>
            <input type="text" id="minTimeInput" placeholder="e.g. 1d5h or leave blank to disable">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">If time since last end is less than this, the Start/End controls will be hidden. Leave blank to disable.</small>
        </div>
        <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="document.getElementById('minTimeModal').classList.remove('active')">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="saveMinTime()">Save</button>
        </div>
    </div>
</div>

<!-- New Event Modal -->
<div class="modal-overlay" id="newEventModal" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="modal">
        <h2>Add Past Event</h2>
        <form method="post" action="{% url 'do_again_create_event' %}" id="eventForm" onsubmit="return handleEventSubmit(event)">
            {% csrf_token %}
            <div class="form-group">
                <label>Title *</label>
                <input type="text" name="title" required placeholder="e.g. Started learning Python" autofocus>
            </div>
            <div class="form-group">
                <label>Time Ago</label>
                <input type="text" name="time_ago" id="eventTimeInput" placeholder="Leave blank for now, or e.g. 1h30m, 2h, 45m">
                <input type="hidden" name="date" id="eventDateHidden">
                <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">Examples: blank = now, 1h = 1 hour ago, 1h30m = 1 hour 30 min ago, 2d = 2 days ago</small>
            </div>
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="this.closest('.modal-overlay').classList.remove('active')">Cancel</button>
                <button type="submit" class="btn btn-primary">Add Event</button>
            </div>
        </form>
    </div>
</div>

<script>
// Parse time offset string to milliseconds (returns 0 if blank/invalid)
function parseTimeOffsetMs(input) {
    if (!input || input.trim() === '') return 0;
    let totalMs = 0;
    const dayMatch = input.match(/(\d+)d/);
    const hourMatch = input.match(/(\d+)h/);
    const minMatch = input.match(/(\d+)m/);
    const secMatch = input.match(/(\d+)s/);
    if (dayMatch) totalMs += parseInt(dayMatch[1]) * 24 * 60 * 60 * 1000;
    if (hourMatch) totalMs += parseInt(hourMatch[1]) * 60 * 60 * 1000;
    if (minMatch) totalMs += parseInt(minMatch[1]) * 60 * 1000;
    if (secMatch) totalMs += parseInt(secMatch[1]) * 1000;
    return totalMs;
}

// Format dates in browser's local timezone
(function() {
    const dateOpts = { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
    };
    document.querySelectorAll('[data-date-display]').forEach(el => {
        const card = el.closest('.event-card');
        const startDate = new Date(card.dataset.eventStart);
        let text = 'Start: ' + startDate.toLocaleString('en-US', dateOpts);
        if (card.dataset.eventEnd) {
            const endDate = new Date(card.dataset.eventEnd);
            text += '\nEnd: ' + endDate.toLocaleString('en-US', dateOpts);
        }
        el.style.whiteSpace = 'pre-line';
        el.textContent = text;
    });
})();

// Event timer updates
(function() {
    function updateTimers() {
        document.querySelectorAll('[data-timer]').forEach(el => {
            const eventCard = el.closest('.event-card');
            const minMs = parseTimeOffsetMs(eventCard.dataset.minTime || '');
            const now = new Date();

            // If within min_time window, show countdown and hide action rows
            const eventId = eventCard.dataset.eventId;
            const startActions = document.getElementById('startActions' + eventId);
            const endActions = document.getElementById('endActions' + eventId);
            if (minMs && eventCard.dataset.eventEnd) {
                const unlockTime = new Date(eventCard.dataset.eventEnd).getTime() + minMs;
                const remaining = unlockTime - now.getTime();
                if (remaining > 0) {
                    if (startActions) startActions.style.display = 'none';
                    if (endActions) endActions.style.display = 'none';
                    const days = Math.floor(remaining / 86400000);
                    const hours = Math.floor((remaining % 86400000) / 3600000);
                    const mins = Math.floor((remaining % 3600000) / 60000);
                    const secs = Math.floor((remaining % 60000) / 1000);
                    if (days > 0) {
                        el.textContent = 'Ready in ' + days + 'd ' + hours + 'h';
                    } else if (hours > 0) {
                        el.textContent = 'Ready in ' + hours + 'h ' + mins + 'm';
                    } else if (mins > 0) {
                        el.textContent = 'Ready in ' + mins + 'm ' + secs + 's';
                    } else {
                        el.textContent = 'Ready in ' + secs + 's';
                    }
                    return;
                } else {
                    if (startActions) startActions.style.display = '';
                    if (endActions) endActions.style.display = '';
                }
            }

            const refDate = eventCard.dataset.eventEnd
                ? new Date(eventCard.dataset.eventEnd)
                : new Date(eventCard.dataset.eventStart);
            const diff = now - refDate;
            
            if (diff < 0) {
                el.textContent = 'Future event';
                return;
            }
            
            const days = Math.floor(diff / 86400000);
            const hours = Math.floor((diff % 86400000) / 3600000);
            const mins = Math.floor((diff % 3600000) / 60000);
            const secs = Math.floor((diff % 60000) / 1000);
            
            if (days > 365) {
                const years = Math.floor(days / 365);
                const remainingDays = days % 365;
                el.textContent = years + 'y ' + remainingDays + 'd ago';
            } else if (days > 0) {
                el.textContent = days + 'd ' + hours + 'h ago';
            } else if (hours > 0) {
                el.textContent = hours + 'h ' + mins + 'm ago';
            } else if (mins > 0) {
                el.textContent = mins + 'm ' + secs + 's ago';
            } else {
                el.textContent = secs + 's ago';
            }
        });
    }
    updateTimers();
    setInterval(updateTimers, 1000);
})();

function sendUpdate(eventId, action) {
    const card = document.querySelector('[data-event-id="' + eventId + '"]');
    const startInputVal = document.getElementById('startInput' + eventId).value.trim();
    const endInput = document.getElementById('endInput' + eventId).value;
    const endDate = endInput.trim() ? parseTimeOffset(endInput) : null;

    // Determine start datetime
    let startDate;
    if (startInputVal) {
        startDate = parseTimeOffset(startInputVal);
    } else if (action === 'end' && card.dataset.eventEnd) {
        // end action on event that already has an end_time: apply default_duration if set
        const defaultDuration = parseInt(card.dataset.defaultDuration || '0', 10);
        if (defaultDuration > 0) {
            const endTime = endDate ? endDate : new Date();
            startDate = new Date(endTime - defaultDuration * 60 * 1000);
        } else {
            startDate = new Date();
        }
    } else {
        startDate = new Date();
    }

    const body = {
        action: action,
        datetime: startDate.toISOString(),
    };
    if (endDate) {
        body.end_datetime = endDate.toISOString();
    }

    fetch('/do_again/event/' + eventId + '/update/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(body)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Clear all input fields
            document.querySelectorAll('[id^="startInput"], [id^="endInput"]').forEach(input => {
                input.value = '';
            });
            location.reload();
        } else {
            alert('Error updating event: ' + (data.error || ''));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error updating event');
    });
}

function startEvent(eventId) {
    sendUpdate(eventId, 'start');
}

function endEvent(eventId) {
    sendUpdate(eventId, 'end');
}

function deleteEvent(eventId) {
    if (!confirm('Are you sure you want to delete this event?')) {
        return;
    }
    
    fetch('/do_again/event/' + eventId + '/delete/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            alert('Error deleting event');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error deleting event');
    });
}

// Parse time offset input and calculate datetime
function parseTimeOffset(input) {
    if (!input || input.trim() === '') {
        return new Date();
    }
    
    const now = new Date();
    let totalMs = 0;
    
    // Parse patterns like "1h30m", "2h", "45m", "2d", "1d5h30m"
    const dayMatch = input.match(/(\d+)d/);
    const hourMatch = input.match(/(\d+)h/);
    const minMatch = input.match(/(\d+)m/);
    const secMatch = input.match(/(\d+)s/);
    
    if (dayMatch) totalMs += parseInt(dayMatch[1]) * 24 * 60 * 60 * 1000;
    if (hourMatch) totalMs += parseInt(hourMatch[1]) * 60 * 60 * 1000;
    if (minMatch) totalMs += parseInt(minMatch[1]) * 60 * 1000;
    if (secMatch) totalMs += parseInt(secMatch[1]) * 1000;
    
    return new Date(now - totalMs);
}

function handleEventSubmit(event) {
    event.preventDefault();
    
    const timeInput = document.getElementById('eventTimeInput').value;
    const calculatedDate = parseTimeOffset(timeInput);
    
    // Format for Django: ISO format
    const dateHidden = document.getElementById('eventDateHidden');
    dateHidden.value = calculatedDate.toISOString();
    
    // Submit the form
    event.target.submit();
    return false;
}

function openMinTimeModal(eventId, currentValue) {
    document.getElementById('minTimeEventId').value = eventId;
    document.getElementById('minTimeInput').value = currentValue || '';
    document.getElementById('minTimeModal').classList.add('active');
    document.getElementById('minTimeInput').focus();
}

function saveMinTime() {
    const eventId = document.getElementById('minTimeEventId').value;
    const minTime = document.getElementById('minTimeInput').value.trim();

    fetch('/do_again/event/' + eventId + '/set-min-time/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ min_time_between_events: minTime })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const card = document.querySelector('[data-event-id="' + eventId + '"]');
            if (card) card.dataset.minTime = minTime;
            document.getElementById('minTimeModal').classList.remove('active');
        } else {
            alert('Error saving min time: ' + (data.error || ''));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving min time');
    });
}

// Auto-focus on modal open
document.getElementById('newEventModal').addEventListener('transitionend', function(e) {
    if (this.classList.contains('active')) {
        this.querySelector('input[name="title"]').focus();
    }
});

function openDurationModal(eventId, currentDuration) {
    document.getElementById('durationEventId').value = eventId;
    document.getElementById('durationInput').value = currentDuration || 0;
    document.getElementById('durationModal').classList.add('active');
    document.getElementById('durationInput').focus();
}

function saveDuration() {
    const eventId = document.getElementById('durationEventId').value;
    const duration = parseInt(document.getElementById('durationInput').value || '0', 10);

    fetch('/do_again/event/' + eventId + '/set-duration/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({ default_duration: duration })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Update the card's data attribute without a full reload
            const card = document.querySelector('[data-event-id="' + eventId + '"]');
            if (card) card.dataset.defaultDuration = duration;
            document.getElementById('durationModal').classList.remove('active');
        } else {
            alert('Error saving duration: ' + (data.error || ''));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving duration');
    });
}
</script>

</body>
</html>
