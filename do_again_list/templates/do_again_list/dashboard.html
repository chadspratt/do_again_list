<!DOCTYPE html>
<html>
<head>
    <title>Do Again List</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f0f2f5; color: #333; padding: 20px; }

        /* Header */
        .header { background: #fff; border-radius: 8px; padding: 20px 24px; margin-bottom: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.1); display: flex; justify-content: space-between; align-items: center; }
        .header h1 { font-size: 1.8rem; }

        /* Messages */
        .messages { margin-bottom: 16px; }
        .messages .success { background: #d4edda; color: #155724; padding: 10px 14px; border-radius: 6px; margin-bottom: 6px; }
        .messages .error { background: #f8d7da; color: #721c24; padding: 10px 14px; border-radius: 6px; margin-bottom: 6px; }

        /* Buttons */
        .btn { display: inline-block; padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: .85rem; text-decoration: none; color: #fff; }
        .btn-primary { background: #0d6efd; }
        .btn-primary:hover { background: #0b5ed7; }
        .btn-success { background: #198754; }
        .btn-success:hover { background: #157347; }
        .btn-danger { background: #dc3545; }
        .btn-danger:hover { background: #bb2d3b; }
        .btn-secondary { background: #6c757d; }
        .btn-secondary:hover { background: #5a6268; }
        .btn-sm { padding: 6px 12px; font-size: .8rem; }

        /* Modal / forms */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,.4); z-index: 100; justify-content: center; align-items: flex-start; padding-top: 80px; }
        .modal-overlay.active { display: flex; }
        .modal { background: #fff; border-radius: 10px; padding: 24px; width: 500px; max-width: 95vw; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 30px rgba(0,0,0,.2); }
        .modal h2 { margin-bottom: 16px; font-size: 1.2rem; }
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; font-weight: 600; margin-bottom: 4px; font-size: .85rem; }
        .form-group input, .form-group textarea { width: 100%; padding: 8px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: .9rem; }
        .form-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 16px; }

        /* Events Grid */
        .events-container { max-width: 1500px; margin: 0 auto; }
        .events-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(236px, 1fr)); gap: 16px; }
        .event-card { background: #fff; border-radius: 8px; padding: 20px; box-shadow: 0 1px 3px rgba(0,0,0,.1); border-left: 4px solid #0d6efd; position: relative; }
        .event-card .event-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; color: #1a1a1a; padding-right: 30px; }
        .event-card .event-date { font-size: .85rem; color: #666; margin-bottom: 12px; }
        .event-card .event-timer { font-size: 1.5rem; font-weight: 700; color: #0d6efd; margin-bottom: 16px; min-height: 36px; }
        .event-card .event-actions { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .event-card .event-actions input[type="text"] { flex: 1; min-width: 100px; padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: .8rem; }
        .event-card .delete-icon { position: absolute; top: 12px; right: 12px; cursor: pointer; font-size: 1.2rem; opacity: 0.5; transition: opacity 0.2s; }
        .event-card .delete-icon:hover { opacity: 1; }
        .event-card .settings-icon { position: absolute; top: 12px; right: 38px; cursor: pointer; font-size: 1.2rem; opacity: 0.5; transition: opacity 0.2s; }
        .event-card .settings-icon:hover { opacity: 1; }
        .events-empty { text-align: center; color: #999; padding: 60px 20px; font-size: 1.1rem; background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.1); }

        /* Page Layout */
        .page-layout { display: flex; gap: 20px; align-items: flex-start; }
        .pending-panel { width: 280px; flex-shrink: 0; }
        .pending-header { font-size: .85rem; font-weight: 700; color: #888; text-transform: uppercase; letter-spacing: .06em; margin-bottom: 12px; padding: 0 4px; }
        .main-panel { flex: 1; min-width: 0; }
        .pending-card { background: #fff; border-radius: 8px; padding: 14px 16px; box-shadow: 0 1px 3px rgba(0,0,0,.1); border-left: 4px solid #adb5bd; position: relative; margin-bottom: 10px; }
        .pending-card .event-title { font-size: .95rem; font-weight: 600; color: #1a1a1a; padding-right: 56px; margin-bottom: 10px; }
        .pending-card .delete-icon { position: absolute; top: 10px; right: 10px; cursor: pointer; font-size: 1.1rem; opacity: 0.5; transition: opacity 0.2s; }
        .pending-card .delete-icon:hover { opacity: 1; }
        .pending-card .settings-icon { position: absolute; top: 10px; right: 34px; cursor: pointer; font-size: 1.1rem; opacity: 0.5; transition: opacity 0.2s; }
        .pending-card .settings-icon:hover { opacity: 1; }
        .pending-card .event-actions { display: flex; gap: 6px; align-items: center; }
        .pending-card .event-actions input[type="text"] { flex: 1; min-width: 70px; padding: 5px 8px; border: 1px solid #ccc; border-radius: 4px; font-size: .75rem; }
        .pending-empty { color: #999; font-size: .85rem; text-align: center; padding: 20px 12px; background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,.1); }
    </style>
</head>
<body>

{% if messages %}
<div class="messages">
    {% for message in messages %}
    <div class="{{ message.tags }}">{{ message }}</div>
    {% endfor %}
</div>
{% endif %}

<!-- Header -->
<div class="header">
    <h1>‚è±Ô∏è Do Again List</h1>
    <button class="btn btn-primary" onclick="document.getElementById('newEventModal').classList.add('active')">+ Add Event</button>
</div>

<!-- Main Layout: pending panel left, events right -->
<div class="page-layout">

    <!-- Pending Events Panel -->
    <div class="pending-panel">
        <div class="pending-header">Pending</div>
        <div id="pendingList">
            {% if pending_events %}
            {% for event in pending_events %}
            <div class="pending-card" data-event-id="{{ event.id }}" data-default-duration="{{ event.default_duration }}" data-min-duration="{{ event.min_duration }}" data-max-duration="{{ event.max_duration }}" data-min-time="{{ event.min_time_between_events }}" data-max-time="{{ event.max_time_between_events }}">
                <span class="delete-icon" data-action="delete" title="Delete">üóëÔ∏è</span>
                <span class="settings-icon" data-action="settings" title="Settings">‚öôÔ∏è</span>
                <div class="event-title">{{ event.title }}</div>
                <div class="event-actions">
                    <input type="text" placeholder="e.g. 1h30m" id="startInput{{ event.id }}">
                    <button class="btn btn-success btn-sm" data-action="start">Start</button>
                </div>
                <div class="event-actions" style="margin-top:6px">
                    <input type="text" placeholder="e.g. 1h30m" id="endInput{{ event.id }}">
                    <button class="btn btn-primary btn-sm" data-action="end">End</button>
                </div>
            </div>
            {% endfor %}
            {% else %}
            <div class="pending-empty">No pending events.</div>
            {% endif %}
        </div>
    </div>

    <!-- Events Grid -->
    <div class="main-panel">
    <div class="events-container">
    <div class="events-grid" id="eventsList">
        {% if events %}
        {% for event in events %}
        <div class="event-card" data-event-id="{{ event.id }}" data-event-start="{% if event.start_time %}{{ event.start_time.isoformat }}{% endif %}" data-event-end="{% if event.end_time %}{{ event.end_time.isoformat }}{% endif %}" data-default-duration="{{ event.default_duration }}" data-min-duration="{{ event.min_duration }}" data-max-duration="{{ event.max_duration }}" data-min-time="{{ event.min_time_between_events }}" data-max-time="{{ event.max_time_between_events }}">
            <span class="delete-icon" data-action="delete" title="Delete event">üóëÔ∏è</span>
            <span class="settings-icon" data-action="settings" title="Event settings">‚öôÔ∏è</span>
            <div class="event-title">{{ event.title }}</div>
            <div class="event-date" data-date-display="{{ event.id }}"></div>
            <div class="event-timer" data-timer="{{ event.id }}"></div>
            <div class="event-actions" id="startActions{{ event.id }}">
                <input type="text" placeholder="start e.g. 1h30m" id="startInput{{ event.id }}"{% if not event.end_time %} style="display:none"{% endif %}>
                <button class="btn btn-success btn-sm" data-action="start" title="Start"{% if not event.end_time %} style="display:none"{% endif %}>Start</button>
            </div>
            <div class="event-actions" id="endActions{{ event.id }}" style="margin-top: 6px;">
                <input type="text" placeholder="end e.g. 1h30m" id="endInput{{ event.id }}">
                <button class="btn btn-primary btn-sm" data-action="end" title="End">End</button>
            </div>
        </div>
        {% endfor %}
        {% else %}
        <div class="events-empty">No events yet. Click "Add Event" to create your first one.</div>
        {% endif %}
    </div>
    </div>
    </div>

</div>

<!-- Event Settings Modal -->
<div class="modal-overlay" id="settingsModal" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="modal">
        <h2>Event Settings ‚Äî <span id="settingsEventTitle" style="font-weight: normal; color: #555;"></span></h2>
        <input type="hidden" id="settingsEventId">
        <div class="form-group">
            <label>Default Duration (minutes)</label>
            <input type="number" id="settingsDefaultDuration" min="0" placeholder="e.g. 60">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">Auto-fill start time when clicking End and the start input is blank. 0 = disabled.</small>
        </div>
        <div class="form-group">
            <label>Min Duration (e.g. 1h30m)</label>
            <input type="text" id="settingsMinDuration" placeholder="e.g. 30m">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">Countdown shown while event is active, until this duration has elapsed since start.</small>
        </div>
        <div class="form-group">
            <label>Max Duration (e.g. 2h)</label>
            <input type="text" id="settingsMaxDuration" placeholder="e.g. 2h">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">After min duration, counts down to this. Can go negative to show overtime.</small>
        </div>
        <div class="form-group">
            <label>Min Time Between Events (e.g. 1d5h)</label>
            <input type="text" id="settingsMinTime" placeholder="e.g. 1d5h">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">After ending, hides controls until this much time has passed. Countdown shown.</small>
        </div>
        <div class="form-group">
            <label>Max Time Between Events (e.g. 2d)</label>
            <input type="text" id="settingsMaxTime" placeholder="e.g. 2d">
            <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">After min cooldown, counts down to this. Can go negative to show overdue.</small>
        </div>
        <div class="form-actions">
            <button type="button" class="btn btn-secondary" onclick="document.getElementById('settingsModal').classList.remove('active')">Cancel</button>
            <button type="button" class="btn btn-primary" onclick="saveSettings()">Save</button>
        </div>
    </div>
</div>

<!-- New Event Modal -->
<div class="modal-overlay" id="newEventModal" onclick="if(event.target===this)this.classList.remove('active')">
    <div class="modal">
        <h2>Add Past Event</h2>
        <form method="post" action="{% url 'do_again_create_event' %}" id="eventForm" onsubmit="return handleEventSubmit(event)">
            {% csrf_token %}
            <div class="form-group">
                <label>Title *</label>
                <input type="text" name="title" required placeholder="e.g. Started learning Python" autofocus>
            </div>
            <div class="form-group">
                <label>Time Ago</label>
                <input type="text" name="time_ago" id="eventTimeInput" placeholder="e.g. 1h30m, 2h, 45m ‚Äî or leave blank for now">
                <input type="hidden" name="date" id="eventDateHidden">
                <input type="hidden" name="pending" id="eventPendingHidden" value="">
                <small style="color: #666; font-size: 0.8rem; display: block; margin-top: 4px;">Examples: blank = now, 1h = 1 hour ago, 2d = 2 days ago</small>
            </div>
            <div class="form-group" style="display:flex;align-items:center;gap:8px;">
                <input type="checkbox" id="eventPending" style="width:auto;margin:0;">
                <label for="eventPending" style="font-weight:normal;margin:0;font-size:.9rem;">Add as <strong>Pending</strong> ‚Äî no start time yet</label>
            </div>
            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="this.closest('.modal-overlay').classList.remove('active')">Cancel</button>
                <button type="submit" class="btn btn-primary">Add Event</button>
            </div>
        </form>
    </div>
</div>

<script>
// Parse time offset string to milliseconds (returns 0 if blank/invalid)
function parseTimeOffsetMs(input) {
    if (!input || input.trim() === '') return 0;
    let totalMs = 0;
    const dayMatch = input.match(/(\d+)d/);
    const hourMatch = input.match(/(\d+)h/);
    const minMatch = input.match(/(\d+)m/);
    const secMatch = input.match(/(\d+)s/);
    if (dayMatch) totalMs += parseInt(dayMatch[1]) * 24 * 60 * 60 * 1000;
    if (hourMatch) totalMs += parseInt(hourMatch[1]) * 60 * 60 * 1000;
    if (minMatch) totalMs += parseInt(minMatch[1]) * 60 * 1000;
    if (secMatch) totalMs += parseInt(secMatch[1]) * 1000;
    return totalMs;
}

// Format dates in browser's local timezone
(function() {
    const dateOpts = { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric',
        hour: 'numeric',
        minute: '2-digit',
        hour12: true
    };
    document.querySelectorAll('[data-date-display]').forEach(el => {
        const card = el.closest('.event-card');
        if (!card || !card.dataset.eventStart) return;
        const startDate = new Date(card.dataset.eventStart);
        let text = 'Start: ' + startDate.toLocaleString('en-US', dateOpts);
        if (card.dataset.eventEnd) {
            const endDate = new Date(card.dataset.eventEnd);
            text += '\nEnd: ' + endDate.toLocaleString('en-US', dateOpts);
        }
        el.style.whiteSpace = 'pre-line';
        el.textContent = text;
    });
})();

// Event timer updates
(function() {
    function formatCountdown(ms, label) {
        const abs = Math.abs(ms);
        const sign = ms < 0 ? '-' : '';
        const days = Math.floor(abs / 86400000);
        const hours = Math.floor((abs % 86400000) / 3600000);
        const mins = Math.floor((abs % 3600000) / 60000);
        const secs = Math.floor((abs % 60000) / 1000);
        let time;
        if (days > 0) {
            time = sign + days + 'd ' + hours + 'h';
        } else if (hours > 0) {
            time = sign + hours + 'h ' + mins + 'm';
        } else if (mins > 0) {
            time = sign + mins + 'm ' + secs + 's';
        } else {
            time = sign + secs + 's';
        }
        return label + ' ' + time;
    }

    function formatElapsed(ms) {
        const days = Math.floor(ms / 86400000);
        const hours = Math.floor((ms % 86400000) / 3600000);
        const mins = Math.floor((ms % 3600000) / 60000);
        const secs = Math.floor((ms % 60000) / 1000);
        if (days > 365) {
            const years = Math.floor(days / 365);
            const remainingDays = days % 365;
            return years + 'y ' + remainingDays + 'd ago';
        } else if (days > 0) {
            return days + 'd ' + hours + 'h ago';
        } else if (hours > 0) {
            return hours + 'h ' + mins + 'm ago';
        } else if (mins > 0) {
            return mins + 'm ' + secs + 's ago';
        } else {
            return secs + 's ago';
        }
    }

    function updateTimers() {
        const now = Date.now();
        document.querySelectorAll('[data-timer]').forEach(el => {
            const card = el.closest('.event-card');
            const eventId = card.dataset.eventId;
            const startActions = document.getElementById('startActions' + eventId);
            const endActions = document.getElementById('endActions' + eventId);
            if (!card.dataset.eventStart) { el.textContent = ''; return; }
            const startMs = new Date(card.dataset.eventStart).getTime();
            const hasEnd = !!card.dataset.eventEnd;
            const endMs = hasEnd ? new Date(card.dataset.eventEnd).getTime() : 0;
            const minDurMs = parseTimeOffsetMs(card.dataset.minDuration || '');
            const maxDurMs = parseTimeOffsetMs(card.dataset.maxDuration || '');
            const minTimeMs = parseTimeOffsetMs(card.dataset.minTime || '');
            const maxTimeMs = parseTimeOffsetMs(card.dataset.maxTime || '');

            // --- Event is started (no end_time) ---
            if (!hasEnd) {
                // Show end actions, hide start actions (existing behavior for open events)
                if (startActions) startActions.style.display = '';
                if (endActions) endActions.style.display = '';
                const elapsed = now - startMs;

                if (minDurMs && elapsed < minDurMs) {
                    // Phase 1: countdown to start_time + min_duration
                    el.textContent = formatCountdown(minDurMs - elapsed, 'Min in');
                    return;
                }
                if (maxDurMs) {
                    // Phase 2: countdown to start_time + max_duration (can go negative)
                    const remaining = (startMs + maxDurMs) - now;
                    el.textContent = formatCountdown(remaining, 'Max in');
                    return;
                }
                // Fallback: count up from start_time
                el.textContent = elapsed >= 0 ? formatElapsed(elapsed) : 'Future event';
                return;
            }

            // --- Event is ended (has end_time) ---
            const sincEnd = now - endMs;

            if (minTimeMs && sincEnd < minTimeMs) {
                // Phase 1: countdown to end_time + min_time, hide controls
                if (startActions) startActions.style.display = 'none';
                if (endActions) endActions.style.display = 'none';
                el.textContent = formatCountdown(minTimeMs - sincEnd, 'Ready in');
                return;
            }

            // Past min cooldown: show controls
            if (startActions) startActions.style.display = '';
            if (endActions) endActions.style.display = '';

            if (maxTimeMs) {
                // Phase 2: countdown to end_time + max_time (can go negative)
                const remaining = (endMs + maxTimeMs) - now;
                el.textContent = formatCountdown(remaining, 'Due in');
                return;
            }

            // Fallback: count up from end_time
            el.textContent = sincEnd >= 0 ? formatElapsed(sincEnd) : 'Future event';
        });
    }
    updateTimers();
    setInterval(updateTimers, 1000);
})();

function sendUpdate(eventId, action) {
    const card = document.querySelector('[data-event-id="' + eventId + '"]');
    const startInputVal = document.getElementById('startInput' + eventId).value.trim();
    const endInput = document.getElementById('endInput' + eventId).value;
    const endDate = endInput.trim() ? parseTimeOffset(endInput) : null;

    // Determine start datetime
    let startDate;
    if (startInputVal) {
        startDate = parseTimeOffset(startInputVal);
    } else if (action === 'end' && card.dataset.eventEnd) {
        // end action on event that already has an end_time: apply default_duration if set
        const defaultDuration = parseInt(card.dataset.defaultDuration || '0', 10);
        if (defaultDuration > 0) {
            const endTime = endDate ? endDate : new Date();
            startDate = new Date(endTime - defaultDuration * 60 * 1000);
        } else {
            startDate = new Date();
        }
    } else {
        startDate = new Date();
    }

    const body = {
        action: action,
        datetime: startDate.toISOString(),
    };
    if (endDate) {
        body.end_datetime = endDate.toISOString();
    }

    fetch('/do_again/api/events/' + eventId + '/update/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(body)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            // Clear all input fields
            document.querySelectorAll('[id^="startInput"], [id^="endInput"]').forEach(input => {
                input.value = '';
            });
            location.reload();
        } else {
            alert('Error updating event: ' + (data.error || ''));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error updating event');
    });
}

// Attach card action handlers via event delegation
function attachCardDelegation(containerId, cardSelector) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.addEventListener('click', function(e) {
        const card = e.target.closest(cardSelector);
        if (!card) return;
        const eventId = card.dataset.eventId;
        const action = e.target.dataset.action;
        if (action === 'delete') deleteEvent(eventId);
        else if (action === 'settings') openSettingsModal(eventId);
        else if (action === 'start') startEvent(eventId);
        else if (action === 'end') endEvent(eventId);
    });
}
attachCardDelegation('eventsList', '.event-card');
attachCardDelegation('pendingList', '.pending-card');

function startEvent(eventId) {
    sendUpdate(eventId, 'start');
}

function endEvent(eventId) {
    sendUpdate(eventId, 'end');
}

function deleteEvent(eventId) {
    if (!confirm('Are you sure you want to delete this event?')) {
        return;
    }
    
    fetch('/do_again/api/events/' + eventId + '/delete/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            location.reload();
        } else {
            alert('Error deleting event');
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error deleting event');
    });
}

// Parse time offset input and calculate datetime
function parseTimeOffset(input) {
    if (!input || input.trim() === '') {
        return new Date();
    }
    
    const now = new Date();
    let totalMs = 0;
    
    // Parse patterns like "1h30m", "2h", "45m", "2d", "1d5h30m"
    const dayMatch = input.match(/(\d+)d/);
    const hourMatch = input.match(/(\d+)h/);
    const minMatch = input.match(/(\d+)m/);
    const secMatch = input.match(/(\d+)s/);
    
    if (dayMatch) totalMs += parseInt(dayMatch[1]) * 24 * 60 * 60 * 1000;
    if (hourMatch) totalMs += parseInt(hourMatch[1]) * 60 * 60 * 1000;
    if (minMatch) totalMs += parseInt(minMatch[1]) * 60 * 1000;
    if (secMatch) totalMs += parseInt(secMatch[1]) * 1000;
    
    return new Date(now - totalMs);
}

function handleEventSubmit(e) {
    e.preventDefault();

    const isPending = document.getElementById('eventPending').checked;
    document.getElementById('eventPendingHidden').value = isPending ? 'true' : '';

    if (!isPending) {
        const timeInput = document.getElementById('eventTimeInput').value;
        const calculatedDate = parseTimeOffset(timeInput);
        document.getElementById('eventDateHidden').value = calculatedDate.toISOString();
    } else {
        document.getElementById('eventDateHidden').value = '';
    }

    e.target.submit();
    return false;
}

function openSettingsModal(eventId) {
    const card = document.querySelector('[data-event-id="' + eventId + '"]');
    document.getElementById('settingsEventId').value = eventId;
    document.getElementById('settingsEventTitle').textContent = card.querySelector('.event-title').textContent.trim();
    document.getElementById('settingsDefaultDuration').value = card.dataset.defaultDuration || 0;
    document.getElementById('settingsMinDuration').value = card.dataset.minDuration || '';
    document.getElementById('settingsMaxDuration').value = card.dataset.maxDuration || '';
    document.getElementById('settingsMinTime').value = card.dataset.minTime || '';
    document.getElementById('settingsMaxTime').value = card.dataset.maxTime || '';
    document.getElementById('settingsModal').classList.add('active');
    document.getElementById('settingsDefaultDuration').focus();
}

function saveSettings() {
    const eventId = document.getElementById('settingsEventId').value;
    const payload = {
        default_duration: parseInt(document.getElementById('settingsDefaultDuration').value || '0', 10),
        min_duration: document.getElementById('settingsMinDuration').value.trim(),
        max_duration: document.getElementById('settingsMaxDuration').value.trim(),
        min_time_between_events: document.getElementById('settingsMinTime').value.trim(),
        max_time_between_events: document.getElementById('settingsMaxTime').value.trim(),
    };

    fetch('/do_again/api/events/' + eventId + '/settings/', {
        method: 'POST',
        headers: {
            'X-CSRFToken': '{{ csrf_token }}',
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload)
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            const card = document.querySelector('[data-event-id="' + eventId + '"]');
            if (card) {
                card.dataset.defaultDuration = payload.default_duration;
                card.dataset.minDuration = payload.min_duration;
                card.dataset.maxDuration = payload.max_duration;
                card.dataset.minTime = payload.min_time_between_events;
                card.dataset.maxTime = payload.max_time_between_events;
            }
            document.getElementById('settingsModal').classList.remove('active');
        } else {
            alert('Error saving settings: ' + (data.error || ''));
        }
    })
    .catch(error => {
        console.error('Error:', error);
        alert('Error saving settings');
    });
}

// Auto-focus on modal open
document.getElementById('newEventModal').addEventListener('transitionend', function(e) {
    if (this.classList.contains('active')) {
        this.querySelector('input[name="title"]').focus();
    }
});

</script>

</body>
</html>
